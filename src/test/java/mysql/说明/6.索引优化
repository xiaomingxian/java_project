尽可能减少join语句中的nestedLoop[嵌套循环]--永远小结果集驱动大结果集
优先优化messedLoop的内层循环
保证join语句中被驱动表上join条件已经被索引
当无法保证被驱动表的join条件字段被索引 且 内存充足的情况下，不要吝啬joinbuffer的设置[设置大]


1.范围会使该字段后的字段索引用不上  select a,b,c from t1 where a=1 and b>1 order by c desc #b>1会使 c 索引失效
    原因：BTree的工作原理 先排序a,如果遇到相同的再排序b,再遇到相同的再排c  因为b是一个范围，mysql无法利用索引对后面的c进行检索，即c的索引无效
    解决：删除原来三个字段的索引，仅为 a,b建立索引

2.左连接[索引放右表[左表全部展示，右表进行条件限制]] 右连接[同理]
    解决：交换表顺序 或者left/right交换


============================== 索引优化 ==============================
全值匹配我最爱
最佳左前缀：查询从最左边开始[带头大哥不能死]，并且不跳过索引列[跳过会使后面的索引失效][中间兄弟不能断]
