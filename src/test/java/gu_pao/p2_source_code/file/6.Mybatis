Mybatis文档:https://mybatis.org/mybatis-3/zh/

核心对象的生命周期：
    SqlSessionFactoryBuilder(创建完SqlSession就销毁)[方法局部method]
    SqlSessionFactory(单例：应用的整个生命周期都存在，用来创建会话)[应用级别application]
    SqlSession[请求和操作request/method]
    Mapper[方法method 与Session的生命周期一致] 通过SqlSession.getMapper(xxxMapper.xml)获得


#标签
    <cache>
    <cache-ref>
    <resultMap>
    <sql>
    <insert> <update> <delete> <select>
#属性
    <cacheEnabled>  缓存
    <localCacheScope> 缓存范围
    <proxyFactory>  代理工厂
    <lazyLoadingEnable> 延迟加载
    <aggressiveLazyLoading>
    <lazyLoadTriggerMethods>
    <defaultExecutorType> 执行器类型
    <logIMpl> 日志配置

N+1:
    结果嵌套查询：
    1:原本的一次查询  N:查询出n条数据 每条数据再去关联一次查询  #association与collection https://www.cnblogs.com/yansum/p/5819973.html
        select .... <association property='xxx' javaType='com.xxm.Person' column='id'    select='指定的查询方法'>
    <setting name='lazyLoadingEnabled' value='true'/>
        延迟加载开关打开后回一定程度上缓解(在需要用那个字段关联的内容时,才会查询)  #连表查询的好办法
    <setting name='aggressiveLazyLoading' value='true'/>
        #aggressive有侵略性的，积极的 开启后 任何方法的调用都会加载该对象的全部属性
    <setting name='proxyFactory' value='CGLIB'/>
        #Mybatis创建具有延迟加载能力的对象所用到的代理工具 默认是 JAVASSIST
            #JAVASSIST 动态编程https://blog.csdn.net/ShuSheng0007/article/details/81269295
分页：逻辑分页(查出所有数据删选所需数据)/物理分页(使用数据库语法分页 eg:mysql:limit)


缓存：org.apache.ibatis.cache
    顶层接口：Cache #要集成其他缓存 得实现这个接口
    默认实现：PerpetualCache #一级二级缓存都是通过它实现
    装饰：decorators.* #对 PerpetualCache进行了增强 适用于不同的场景
缓存对象什么时候创建？什么情况下被装饰
    一级缓存(本地缓存)：Session级别 #在执行器内 DefaultSqlSession 内的Executor 的父类 BaseExecutor ==>PerpetualCache(localCache)
    二级缓存：

缓存是否清空 flushCache 增删改默认是true 查询是false
一级缓存不跨session(Map)　 两个会话同时操作 A会话对数据做了修改  B会话读取不到,读的还是旧数据
    一级缓存默认打开
二级缓存跨session(二级缓存放在了一级缓存的维护者BaseExecutor的装饰者里 CachingExecutor)　   nameSpace级别 不同session调用相同接口的相同方法会使用缓存 解决一级缓存读到脏数据的问题  在一级缓存之前执行
    二级缓存开启<setting name="cacheEnable" value="true"/> 默认开启  mapper.xml 中还需配置 <cache/>
    默认(全局)：<cache type="org.apache.ibatis.cache.impl.PerpetualCache" size="1024" eviction="LRU" flushInterval="120000" readOnly="false"/>
    关闭某个方法的缓存(标签)：useCache="false"
    淘汰算法:LRU(Least Recently use最近最少使用)  FIFO WEAK(JVM) SOFT(JVM)
    type:可替换为redis等   分布式中使用独立的缓存组件
    readOnly="false" 可以读写 写后返回的是一个copy对象,实体得实现序列化   true是同一个对象，不需要copy速递更快 false更安全
    为什么比一级缓存的范围更广:因为使用了装饰器















