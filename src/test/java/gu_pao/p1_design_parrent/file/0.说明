设计模式：http://c.biancheng.net/view/1333.html

设计原则：
    1 开闭原则(ocp):对扩展开放，对修改关闭
    2 单一职责原则：一个类/接口只负责一个/类功能(只做一件事)
    3 依赖倒置原则：程序要依赖于抽象接口，不要依赖于具体实现(eg:面向接口编程)
    4 接口隔离原则：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上。(eg:b 实现了 a,c 想使用 a 的功能就单独实现 a,反例：a通过b来使用a)
    5 迪米特原则(最少知道原则)()：软件实体之间应尽可能少的发生相互作用(降低类耦合[需要联系的话，通过中介类来做(可能会产生过多的中介类)])每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
    6 里氏替换原则：子类可以扩展父类的功能，但是不能修改父类的方法
    7 合成复用原则(组合/聚合复用原则)：尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系(白箱复用[父类对子类透明])来实现

spring中用到的设计模式：
    工厂模式：BeanFactory
    装饰器模式：BeanWrapper
    代理模式：AopProxy
    单例模式：ApplicationContext
    委派模式：DispatcherServlet
    策略模式：HandlerMapping
    适配器模式：HandlerAdapter
    模版方法模式：JdbcTemplate
    观察者模式：ContextLoaderListener
    ...

====================================================================
工厂模式：(创建型设计模式)
    简单工厂：客户端只需传入工厂类参数，不需要关心创建逻辑(工厂类的职责相对过重，增加新的产品时需要修改工厂类的判断逻辑，违背开闭原则)
    工厂方法：定义一个创建对象的方法，但让实现这个接口的类来决定实例化哪个类，工厂方法让类的实例化推迟到子类中进行(易于扩展，增加工厂实现工厂规则接口)
    抽象工厂(产品族)：

单例：(创建型模式)(构造方法私有，提供公共访问方式)
#在内存中只有一个实例，减少内存开销 可避免对资源的多重占用 设置全局访问点，严格控制访问
#不符合开闭原则 没有接口扩展困难
    1 饿汉(浪费内存空间[用不到的情况下])
    2 懒汉
    3 注册式：枚举/容器
原型模式(创建型模式)
    原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象(不许要构造方法)
    注意事项：必须配备克隆(或可拷贝)方法；对复杂对象或对克隆出的对象进行复杂改造时，易带来风险；深/浅拷贝压迫运用得当
    适用场景：
        类初始化消耗资源较多
        new产生一个对象需要非常繁琐的过程(数据准备,访问权限等)
        构造函数比较复杂
        循环体中产生大量对象时
代理模式：(结构型设计模式)
    为其他对象提供一种代理，来控制对这个对象的访问；代理对象在客户端和目标对象之间起到中介作用；
    优点：
        能将代理对象与真实调用的目标对象分离
        一定程度上降低了系统的耦合度，易于扩展
        代理可以起到保护目标对象的效果
        增强目标对象的职责(专一职责?需要增强的功能让代理类来做)
    缺点：
        会造成系统设计中类的增加(自动生成或者显示加入)
        在客户端和目标对象之间增加了一个代理对象，会造成请求速度加慢
        增加了系统的复杂度
    分类：
        静态代理：显示的写出代理类(不易扩展:eg:被代理类加方法，代理类也得显示的写出来)[不符合开闭原则]
        动态代理：动态生成代理类(更易于扩展)
        静态代理针对于某一种类型进行代理,动态代理没有类型限制
委派模式：(行为模式)[不属于23种设计模式]
    eg:DispatcherServlet
    定义：负责任务的调度和分配，类似代理模式，可以看作是一种特殊情况下的静态代理的全权代理，但是代理模式更注重过程，而委派模式更注重结果
策略模式:(方法已经封装好，没有干预权，只有选择权)
    一个接口对应不同实现[策略们 eg:打折的算法族]
    上下文管理 [持有接口的引用，具体的策略根据实现类的不同而不同]
模版模式：(形式类似与策略模式，但是对方法有干预权)
    定义：公共的部分写在父类中，变化的部分由子类去实现