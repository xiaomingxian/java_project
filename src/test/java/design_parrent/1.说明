设计模式分为三大类：
    创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
    结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
    行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式[s]、
                备忘录模式、状态模式、访问者模式、中介者模式、解释器模式[s]。
    其实还有两类：并发型模式和线程池模式。

类加载是天然的线程安全？？？？为啥

===================================    细节   ============================================
静态代理与装者模式区别:
    静态代理只对用户暴露接口,不能增加额外的方法[增加了也无法通过接口进行调用]
    装饰者直接将 被装饰增强的类暴露给用户


=========================================================================================

1 单例：
    饿汉：线程安全，效率高[非同步]，不能做到延迟加载
    懒汉：效率低[为了线程安全，创建对象的地方加锁了]，可以延迟加载
    双重检测锁：* 由于编译器优化和JVM底层模型原因，可能导致锁顺序发生变化偶尔会失效 [多线程下指令重排]-->解决方式：  interview/t0/mianshi/test/T1_Singten.java
    静态内部类：具备了：延迟加载，线程安全[final修饰只能赋值一次]      ---------------->其他框架常用
    枚举类                      -------->可以做到反序列化，避免反射方式创建对象，没有懒加载      枚举 基于JVM底层实现，是个天然的单例


    漏洞[除枚举(枚举由JVM底层实现)]
    防止反射破解--->在私构造内判断对象是否存在-->不存在就抛出异常[是否加锁]
    反序列化漏洞
         /**
             * 防止反序列化---基于回掉函数
             */
            private Object readResolve() {
                return single1;
            }

    性能测试----懒汉最优--比其他高出一两个数量级


2 工厂模式[创建者与调用者分离]  [产品或产品族]
    简单工厂模式[也叫静态工厂模式，一般使用静态的方法，通过接受参数的不同来返回不同的对象实例]对于新增的产品无能为力，不修改代码无法扩展
        [违反OCP原则，类少]
    工厂方法模式[工厂为接口，其他生产厂商的也为接口继承工厂接口，在实现类中重写制造方法]
        [符合OCP，代码多]
3 抽象工厂[产品族]
        大厂+小作坊[eg:汽车厂：高低端--零件供应商[高低端]]

4 建造者[创建与组装分离]--->常与工厂结合[负责创建]
    客户端只与创建者交流--->具体创建由创建者与工厂交流

5 适配器模式   eg:io的转换流   BufferedReader in = new BufferedReader(new InputStreamReader(System.in));
        1.类适配器使用对象继承的方式，是静态的定义方式   适配器继承被适配类(为了super.xxx()进行方法调用)实现目标类(为了以多态形式进行调用)
        2.适配器继承规范类，并且在内部持有被适配类的接口]
    而对象适配器使用对象组合的方式，是动态组合的方式。

6 代理
    应用场景
        安全代理 屏蔽对真实角色的访问
        远程代理 通过代理类处理远程方法调用[RMI]
        延迟加载 先加载轻量级代理对象[占位],需要时再加载真实对象
    类型：
        静态代理 代理类与被代理类实现共同的接口 代理类持有被代理类的引用 对他做增强
        动态代理
            JDK自带的动态代理
            Javaassist字节码操作库实现  https://www.jianshu.com/p/334a148b420a
            CGLIB
            MyBatis拦截器
            ASM(底层使用指令，可维护性差)

7 组合模式         *** [为用户提供统一的操作接口，隐藏层级结构]
     ● Component（抽象构件）[为用户提供统一的接口，隐藏了层级]：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。
        在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。
     ● Leaf（叶子构件）：它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。
        对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。
     ● Composite（容器构件）：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，
        它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。
        组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，
        可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。

    场景：[可以用树状图表示的结构]
        操作系统中的资源管理器
        GUI中的容器层次图
        xml文件解析
        OA中组织结构的处理
        ***** Junit单元测试框架    底层设计：TestCase(叶子)，TestUnite(容器),Test接口(抽象)

8 装饰器
    对象间的组合[拼装]

9 外观模式[遵守迪米特法则--只与直接的朋友通信，不与陌生人通信] 封装
    eg:JDBC封装后commons提供的DBUtils
        Hibernate提供的工具类，Spring JDBC工具类等

10 享元模式[池技术]
    共享的东西从池中获取，非共享的东西才创建
    应用实例： 1、JAVA 中的 String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面。 2、数据库的数据池。
    优点：大大减少对象的创建，降低系统的内存，使效率提高。
    缺点：提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。

11 责任链
    责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。
    请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，
    这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。Tomcat中的Filter就是使用了责任链模式，
    创建一个Filter除了要在web.xml文件中做相应配置外，还需要实现javax.servlet.Filter接口。

    eg: java中的try catch 对应多个异常信息:当第一个catch不匹配类型时就跳转到下一个
        servlet开发中，过滤器的链式处理
        Struts2中，拦截器的调用


12 迭代器模式[参考List]

13 中介者
    2个同事向中介注册-中介接受到消息后会在内部进行判断-转发[一对一通信]
    eg：MVC C控制器对象是一个中介者 MV[模型,视图]都与控制器打交道

14 命令模式

15 解释器模式[新语言设计]

16 策略模式
    一个接口对应不同实现[策略们 eg:打折的算法族]
    上下文管理 [持有接口的引用，具体的策略根据实现类的不同而不同]

17 模版方法[多态的一种,回掉,钩子(抽闲方法)]
    场景：整体步骤固定 某些部分易变，易变部分可以抽象出来，供子类实现
    开发：数据库访问的框架，Junit单元测试，Servlet中的doGet/doPost,hibernate中模版程序，Spring中的JDBCTemplate,HibernateTemplate等

18 状态模式

19 观察者模式[广播机制]  观察者向发布者注册[在发布者中以集合体现]发布者发布消息-通知集合中所有的对象
    应用场景：servlet中的监听器

20 备忘录模式
    源发类：某个对象的内部状态
    备忘录：对象内部状态的拷贝
    负责人：管理一堆备忘录类

    eg:事物的回滚，ps的历史记录


