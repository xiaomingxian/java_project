设计模式分为三大类：
    创建型模式，共五种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式。
    结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。
    行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、
                备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。
    其实还有两类：并发型模式和线程池模式。

类加载是天然的线程安全？？？？为啥

=========================================================================================
=========================================================================================

1 单例：
    饿汉：线程安全，效率高[非同步]，不能做到延迟加载
    懒汉：效率低[为了线程安全，创建对象的地方加锁了]，可以延迟加载
    双重检测锁：* 由于编译器优化和JVM底层模型原因，可能导致锁顺序发生变化偶尔会失效
    静态内部类：具备了：延迟加载，线程安全[final修饰只能赋值一次]      ---------------->其他框架常用
    枚举类                      -------->可以做到反序列化，避免反射方式创建对象，没有懒加载      枚举 基于JVM底层实现，是个天然的单例


    漏洞[除枚举(枚举由JVM底层实现)]
    防止反射破解--->在私构造内判断对象是否存在-->不存在就抛出异常[是否加锁]
    反序列化漏洞
         /**
             * 防止反序列化---基于回掉函数
             */
            private Object readResolve() {
                return single1;
            }

    性能测试----懒汉最优--比其他高出一两个数量级


2 工厂模式[创建者与调用者分离]  [产品或产品族]
    简单工厂模式[也叫静态工厂模式，一般使用静态的方法，通过接受参数的不同来返回不同的对象实例]对于新增的产品无能为力，不修改代码无法扩展
        [违反OCP原则，类少]
    工厂方法模式[工厂为接口，其他生产厂商的也为接口继承工厂接口，在实现类中重写制造方法]
        [符合OCP，代码多]
    抽象工厂[产品族]
        大厂+小作坊[eg:汽车厂：高低端--零件供应商[高低端]]

3 建造者[创建与组装分离]--->常与工厂结合[负责创建]
    客户端只与创建者交流--->具体创建由创建者与工厂交流
