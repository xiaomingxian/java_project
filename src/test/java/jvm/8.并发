非原子：
    eg:a++/a-- 读取，改变，写入

------------------  马士兵并发编程 ----------------
sychronized(this) 锁定的是当前对象，而不是代码块  如果有另一个代码块没有加锁，那么执行这个方法的时候不需要看对象有没有锁
静态锁锁定的是       class/字节码对象
脏读               读到在写还没有完成的数据   读未加锁 而写加锁但未完成
sychronized 锁可重入  同一类中 或者 子类同步方法调用父类的同步方法
锁遇到异常会被释放   其他线程得到的是执行到一半的代码
---------------------------  volatile
Java 中的线程通信  使用共享内存
所有线程共享主内存
每个线程有自己的工作内存[线程自己的内存+cpu缓冲区]   线程使用主内存中的变量 是先将变量读到自己的缓冲区 如果没加 volatile 一直使用的都是自己缓冲区中的内容，主内存中变量发生变化，此线程中不知道
volatile          标记的变量如果发生改变[某一线程对它做了修改，会把此变量写回主内存]会通知其他线程 他们的缓冲区的内容 已经过期 需要再次从 主内存读取
    线程间的变量可见性  也叫无锁同步
    eg:cocurrentHashMap

sychronized 与 volatile：
    sy..既保证了可见性，又保证了原子性,效率低
    vo..只保证了可见性，不能保证多个线程修改vo..修饰的变量 所带来的不一致问题，效率高

简单的数字运算：Atomic... 原子性操作