======================== 垃圾回收 ========================
1.如何判定为垃圾
    a.引用计数法
         在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器就+1，当引用失效的时候，计数器就-1
         java中不使用此种算法：栈中并没有引用指向 但堆中互指的情况

         指令：-verbose:gc 打印垃圾回收的gc信息；-XX:+PrintGCDetails
    b.可达性分析
        与 GCroot 没有任何引用链相连接的时候，就认为它是不可用  「引用链：从GCroot向下所经过的路线」
        GCRoot:虚拟机栈，方法区「方法区中类所引用的对象，方法取中常量引用的对象」，本地方法栈中引用的对象
2.如何回收
    a.回收策略
        标记清除算法「时间：效率低；空间：不连续空间」
            标记与清除，「标记哪些可以被回收」回收之后会产生不连续的空间  jvm可能会再次出发gc[产生不连续的空间，造成寻址困难]
        复制算法「针对新生代」一般有10%存活 surivor2满了的话 会进行内存担保
            堆：
            NIOw    新生代：Eden[垃圾回收器经常光顾]  Seriver[存活下来的]  Tenured Gen[垃圾回收器很少光顾]
                老年代
            方法区：
            栈 本地方法栈 程序计数器
        标记-整理算法「老年代」「标记-需要回收或者不需要回收的对象往某一端移动」「比标记清理效率高」
        分代收集算法「标记整理与复制算法结合」 「根据内存的分代选择不同的垃圾回收算法」「对于新生代等回收率较高的区域选择复制算法，对于老年代等回收率较低的选择标记整理算法」
    b.垃圾回收器
        Serial  单线程
        Parnew  多线程
        Cms     并发收集器「边扔垃圾边打扫-->对于耗时的标记与清理进行并行操作」「标记清理算法」 用于回收老年代内存「如果用它回收了老年代则不能用它回收新生代：得使用Serial或者Parnew」
            其他收集器跟 Parnew相似，共用了大量代码，使用复制算法
        Parallel Scavenge 多线程 复制算法 回收时间更短「相较于Parnew」 达到可控的吞吐量
            吞吐量：CPU运行用户代码的时间与CPU总消耗时间的比值   =用户代码时间/(用户代码时间+垃圾回收耗时)
            -XX:MaxGCPauseMillis  最大回收停顿-->每次回收时常   如果过小导致回收效率低下，内存占用降不下来，导致回收次数增多  所以要设置合理的大小
            -XX:GCTimeRatio 吞吐量大小(0,100) 默认值99即垃圾回收只能占用1%
        G1「逻辑分区」
            删选回收
