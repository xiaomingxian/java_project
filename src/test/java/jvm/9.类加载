
java虚拟机与程序的生命周期  [java虚拟机本身是一个进程]
    如下几种情况，java虚拟机将结束生命周期【虚拟机实例】
        显示调用  System.exit()
        程序正常结束
        程序在运行过程中遇到了异常或错误而异常终止
        由于操作系统出现的错误而导致java虚拟机进程终止

======================================================类加载器阶段分析=========================================================
在java代码中，类型的加载，连接 与初始化过程都是在程序运行期间完成的
    类型[class/interface/enum...]的加载，   --->最常见的情况[非唯一]:将磁盘上的class文件加载到内存中[jvm管理的内存]
    连接                                  ---->将类与类的关系确立好，并且对字节码的一些处理，校验等 [字节码可以被人为操纵，如果校验不通过，jvm可以拒绝执行]
        类与类的调用关系也是在这一阶段完成的 比如将类与类之间的符号引用变为直接引用
    与初始化                                --->赋值操作
    过程都是在程序运行期间完成的   [这些步骤并非严格一致，不同的厂商有不同的实现]
    =============概要说明==================
    加载：查找并加载类的二进制信息
    连接：
        验证：确保被加载的类的正确性
        准备：为类的静态变量分配内存，并将其初始化为默认值      [static]
        解析：把类中的符号引用转换为直接引用
    初始化：为类的静态化变量赋予正确的初始值
    使用
    卸载
    ===============================

类的初始化时机：所有的java虚拟机实现必须在每个类或接口被java程序 《首次主动使用》 时才初始化他们
    java对类的使用方式可以分为两种
        主动使用：
            1 创建类的实例
            2 访问某个类或接口的静态，或者对静态变量赋值
            3 调用类的静态方法  [2可以归类为：对静态变量的使用与赋值 jvm层面 getStatic指令 putStatic指令][3 invokeStatic指令][指令==java虚拟机注记符]
            4 反射
            5 初始化一个类的子类
            6 java虚拟机启动时被标记为启动类的类(Java Test[包含main方法])[包含main方法的类]
            7 JDK1.7开始支持提供的对动态语言的支持[eg:javaScript] java.lang.invoke.MethodHandle实例的解析结果 REF_getStatic,REF_putStatic,REF_invokeStatic 具柄对应的类没有初始化，则初始化
        被动使用：其他使用类的方式都被看作是类的被动使用，都不会导致类的初始化

-----------------  阶段详解
类加载：
    将类的.class文件中的二进制数据读取到jvm的内存中，将其放在方法区[1.8叫元空间]
        ---然后在内存中创建一个[唯一]java.lang.Class对象用来封装类在方法区的数据结构,并向程序员提供了访问方法区内的数据结构的接口[规范并未说明Class对象放在哪里，HotSpot将其放在方法区]
    加载文件的方式： 从本地系统直接加载[日常最多使用]，通过网络下载.class文件，从zip/jar等归档文件中加载，从专有数据库中提取，将java源文件动态编译为.class文件[eg:jsp专为java代码(servlet代码)转为.class]
=================加载器类型
Jvm自带类加载器：
    跟类加载器[BootStrap]
    扩展类加载器[Extension]
    应用类加载器[System]
用户自定义类加载器：
    特点：java.lang.ClassLoader的子类，用户可以定制类的加载方式
-------------------------详解2
类加载
    类加载器并不需要等到某个类被首次主动使用时才加载它
    JVM规范允许类加载器在预料某个类将要被使用时才加载它，如果在预先加载的时候遇到.class文件缺失或存在错误，类加载器必须在程序首次使用该类时才报告错误(LinkageError),如果类一直没有被程序主动使用就不会报错
类验证：
    连接：类被加载后，就进入到连接阶段，连接就是：将已被读入到内存的二进制数据合并到虚拟机的运行时环境中
        内容
            类文件的结构检查
            语义检查
            字节码验证
            二进制兼容性验证
            ...
    准备：为静态变量开辟空间，并赋默认值
    解析：
初始化：生命处进行初始化；静态代码块处进行初始化    自上而下的顺序
    初始化类的时候得初始化它的父类  但是不是一定要初始化实现的接口[除非使用常量(非编译期确定的常量)]
    当接口初始化时并不要求其父类初始化，只有真正使用到父接口时[如引入进口中所定义的常量时[在运行时期确定常量]]，才会初始化
    调用ClassLoader的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化
------------------
jvm的加载器除 root外有且只有一个父加载器 [root没有父加载器] root=BootStrap
双亲委派[jdk,hotspot]   --->扩展知识：定义类加载器：最终成功的返回目标类的加载器     初始化加载器：所有可以成功返回目标类的类加载器包括定义类加载器
    BootStrap ClassLoader:  JRE/lib/rt.jar或者 -XBootclasspath选项指定的jar包     [jvm参数指定的位置]
    Extension ClassLoader:  JRE/lib/ext/*.jar 或-Djava.ext.dirs指定目录下的jar包 [jvm参数指定的位置]
    App ClassLoader:        classPath 或 -Djava.class.path所指定的目录下的类和jar包 [jvm参数指定的位置]
    Custom ClassLoader:     通过classLoader的子类指定的jar包


