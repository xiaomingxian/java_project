============================ 指令重排  ===================================
指令重排：[底层为了效率等因素会进行重排，现象：代码的顺序与执行顺序并非一致]
    重排：源代码-->编译器优化重排-->指令并行的重排-->内存系统的重排-->最终指令
    计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为一下三种：
        1 单线程环境里确保最终执行结果与代码顺序执行的结果一致  [单线程不用关心指令重排]
        2 处理器在指令重排时必须考虑指令之间的数据依赖性
        3 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测

     重排demo1:
        int x=1//语句1
        int y=12//语句2
        x=x+5
        y=x+y
        语句4可以成为重排后的第一句吗？不可以--违法了依赖性

     demo2:
        int x,y,a,b=0
        线程1:x=a b=1 线程2：y=b a=2
        情况一：没有发生指令重排：结果：x=0 y=0
        情况二：发生指令重排：可能b=1先发生 y=1 a=2先发生 x=2
     demo3:多线程环境下进行的重排可能导致
        ... class xxx{
            int a=0;
            boolen f=true;

            public void m1(){
                a=1；            //语句1
                flag=true;      //语句2
            }
            public void m2(){
                if(flag){
                    a=a+5;      //语句3
                    Sys...println(a)
                }
            }

        }
        //指令重排可能导致的执行顺序 1 3 2  a=5
        //理想顺序 1 2 3    a=6
        //解决策略  加 volatile 禁止指令重排

============================ 内存屏障(Memory Barrier)  ===================================
又称内存栅栏(cpu指令)作用2个：
    1 保证特定操作的顺序执行
    2 保证某些变量的内存可见性(利用该特性实现volatile的内存可见性)

 由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU,不管什么指令都不能和这条指令重排序
 也就是说 《《《《《《  通过插入内存屏障禁止在内存屏障前后的指令前后执行重排序优化 》》》》》》                   ===============》保障了volatiel禁止指令重排的原理？
 内存屏障的另一个作用是强制刷出各种cpu的缓存，因此cpu 上的各个线程都能读取到这些数据的最新版本                    ===============》保障了volatile可见性的原理？

demo:对volatile在进行写操作的时候会在操作后加一条 store屏障指令，将工作中的变量值刷回到主内存中       ======>多线程操作时是在后面加指令前面没有加所以不会先读(个人理解)
    对volatile在进行读操作时会在操作前加一条 load 指令，从主内存中读取共享变量

Synchronized与Lock的区别：
    1 synchronized是关键字 属于jvm层面(底层是通过monitor对象来完成，wait/notify也依赖于monitor，对象只有在同步块或方法中才能调用 wait.notify)
        lock是api层面
        sychronized反编译结果：monitorenter-->加锁    monitorexit-->释放锁[一个正常释放，一个出现异常释放]
               4: monitorenter
               5: aload_1
               6: monitorexit
               7: goto          15
              10: astore_2
              11: aload_1
              12: monitorexit
    2 syc不可中断[除非异常或者正常执行完]  Reentrantlock可中断
                    1 设置超时方法 tryLock(Long timeout,TimeUnit unit)
                    2 lockInterruptibly放代码块中，调用 interrupt()方法可中断
    3 是否是公平锁 sys不是 reen可以是[通过构造参数]
    4 绑定多个条件 syc没有 reen有

生产者消费者之阻塞队列   demo:jvm.test.T11_ProducAndCou.T13_BlockQueue

Callable 适配器模式
    返回值：Fulture.get() 此方法为阻塞方法-->获取值获取不到就阻塞直到获取到值[直到该线程计算完毕]
    多个线程使用同一个FultureTask此task只会执行一次[复用]，如果想执行多次就得创建多个task实例
