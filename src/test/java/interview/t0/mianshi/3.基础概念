============================ 指令重排  ===================================
指令重排：[底层为了效率等因素会进行重排，现象：代码的顺序与执行顺序并非一致]
    重排：源代码-->编译器优化重排-->指令并行的重排-->内存系统的重排-->最终指令
    计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排，一般分为一下三种：
        1 单线程环境里确保最终执行结果与代码顺序执行的结果一致  [单线程不用关心指令重排]
        2 处理器在指令重排时必须考虑指令之间的数据依赖性
        3 多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是无法确定的，结果无法预测

     重排demo1:
        int x=1//语句1
        int y=12//语句2
        x=x+5
        y=x+y
        语句4可以成为重排后的第一句吗？不可以--违法了依赖性

     demo2:
        int x,y,a,b=0
        线程1:x=a b=1 线程2：y=b a=2
        情况一：没有发生指令重排：结果：x=0 y=0
        情况二：发生指令重排：可能b=1先发生 y=1 a=2先发生 x=2
     demo3:多线程环境下进行的重排可能导致
        ... class xxx{
            int a=0;
            boolen f=true;

            public void m1(){
                a=1；            //语句1
                flag=true;      //语句2
            }
            public void m2(){
                if(flag){
                    a=a+5;      //语句3
                    Sys...println(a)
                }
            }

        }
        //指令重排可能导致的执行顺序 1 3 2  a=5
        //理想顺序 1 2 3    a=6
        //解决策略  加 volatile 禁止指令重排

============================ 内存屏障(Memory Barrier)  ===================================
又称内存栅栏(cpu指令)作用2个：
    1 保证特定操作的顺序执行
    2 保证某些变量的内存可见性(利用该特性实现volatile的内存可见性)

 由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU,不管什么指令都不能和这条指令重排序
 也就是说 《《《《《《  通过插入内存屏障禁止在内存屏障前后的指令前后执行重排序优化 》》》》》》                   ===============》保障了volatiel禁止指令重排的原理？
 内存屏障的另一个作用是强制刷出各种cpu的缓存，因此cpu 上的各个线程都能读取到这些数据的最新版本                    ===============》保障了volatile可见性的原理？

demo:对volatile在进行写操作的时候会在操作后加一条 store屏障指令，将工作中的变量值刷回到主内存中       ======>多线程操作时是在后面加指令前面没有加所以不会先读(个人理解)
    对volatile在进行读操作时会在操作前加一条 load 指令，从主内存中读取共享变量