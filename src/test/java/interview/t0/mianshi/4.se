面向对象特征：
    继承:从已有类得到继承信息 常见新类 的过程
    封装：隐藏一切可以隐藏的东西，只向外界提供简单的编程接口
    多态：编译时多态[方法重载]
         运行时多态[方法重写]#条件：1.方法重写 2.父类引用指向子类对象
    抽象：将一类对象的共同特征抽象出来，包括数据抽象与行为抽象#抽象只关注对象有哪些属性和行为，并不关注细节#个人理解[接口/抽象类都属于此范畴]

权限修饰符 public/private/protected/default
    当前包类：o       o       o       o
     同包：  o       x       o        o
     子类    o      x        o        x
    其他包： o       x       x       x

clone与new的区别
    第一步相同都是分配内存[根据类型决定分配多大空间]
    new:调用构造函数填充各个域[初始化]--返回对象引用
    clone:使用原对象的各个域填充新对象的各个域--返回新对象引用 #如何实现深拷贝：1-序列化，2.在clone方法中将成员位置的对象也clone一份

保留字:goto,const

& 1-按位与 2-逻辑与   && 短路与

equals/hashCode ---> T21_Clone
    首先 equals 方法必须满足自反性/对称性/传递性/一致性
String是final不可被继承

为什么函数不能根据返回类型来区分重载：int a(int x)/void a(int x)  当点用时没有使用返回值时无法区分#因为调用时不能指定类型信息，编译器不知道你要调用哪个函数。
    函数的返回值只是作为函数运行之后的一个“状态”，他是保持方法的调用者与被调用者进行通信的关键。并不能 作为某个方法的“标识”。



编码：
    在utf-8中：
        一个汉字占3个字节，包括中文符号。
        一个英文字符占1个字节。
    在gbk中：
        一个汉字占2个字节，包括中文符号。
        一个英文字符占1个字节
    在unicode中：[java默认]
        一个汉字占2个字节，包括中文符号。
        一个英文字符占2个字节。




==与equals
    运算符/方法
    比较基本类型：值;引用类型：地址值/没有重写equals比较的是对象的地址值;重写之后比较的是对象内容


break[完全结束循环]/continue[跳过本次循环执行下次循环]

Math.round(11.5)=12  Math.round(-11.5)=-11 #原理：在原数字的基础上+0.5后取整


switch支持的类型：char,byte,short,int,Character,Byte,Short,Integer,String,enum

String + 底层用的是StringBuilder #字符串的拼接如果放在循环内部那么Sb的创建实在循环内部创建，正确做法：在外部声明Sb,在内部进行拼接

short s1 = 1; s1 = s1 + 1; X short s1 = 1; s1 += 1 o[隐含类型转换]

如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池 中的 Integer 对象
    #装箱的本质是什么呢?当我们给一个 Integer 对 象赋一个 int 值的时候，会调用valueOf(int i){...}从IntegerCache获取 ##IntegerCache是 Integer 的内部类
    #如果整型字面量的值在-128 到 127 之间，那么不会 new 新的 Integer 对象，而是直接引用常量池 中的 Integer 对象



