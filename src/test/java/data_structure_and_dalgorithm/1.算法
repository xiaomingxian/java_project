算法的基本特征：输入，输出，有穷性，确定性，可行性

------------ 时间复杂度，空间复杂度 --------------
算法度量方法：
    1.算法采取的策略，方案
    2.编译产生的代码质量【编译器的优化策略影响代码质量】
    3.问题的输入规模
    4.机器执行指令的速度【硬件条件】

算法复杂度：随着输入规模的增大增长量的抽象
------- ---------- ---------
------- 函数渐进增长
    给定两个函数 f(n),g(n) 如果存在一个整数N,使得所有的n>N【参数的变化（个人理解：线性增长）】，f(n)总是大于g(n) ,那么f(n)的增长渐进快于g(n)【f(n)更耗时】
        函数demo: f(n)=2n/2n+1 3n/3n+1   后面加的常数可以忽略【大数据量时影响效果小】
           demo2: n/4n+8 n^2/2n^2+1     与最高次项相乘的常数可以忽略
           demo3: n^2/2n^2+3n+1  n^3/2n^3+3n+1
           demo4: 3n+1 2n^2 2n^2+3n+1
        通过以上的函数的线性增长图可得：
            判定一个算法的效率时，函数的常数和次要项常常可以忽略，应该关注主项的阶数【最高次幂】

=============== 时间复杂度【算法渐进时间复杂度】 =============
个人理解：T(n)=计算次数的函数    观察计算次数的函数  得出 时间复杂度
语句的执行总次数 T(n) 分析T(n)随n的变化并确定T(n)的数量级   T(n)增长最慢为最优算法
    表达式计作：T(n)=O(f(n)) 表示随问题规模n的增大，算法执行增长率和f(n)的增长率相同
    几个函数对应的时间复杂度：
        循环体的复杂度为 n^循环运行的次数
        1       O(1)        用常数1取代所有的加法常数   eg:输出结果与变量无关
        n       O(n)                                eg:单层for循环
        n*n     O(n^2)      存在最高阶项且阶不为1则去除与这个阶相乘的常数     eg:嵌套for循环
时间复杂度排序：O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n^n)

============== 空间复杂度  ================
S(n)=O(f(n))

