注意：
    原生的实体不能作为Response返回，因为没有序列化？重新创建一份一样的实现序列化接口进行返回/直接序列化工具进行序列化【待验证】
    可以使用这个进行属性拷贝：    BeanUtils.copyProperties();
------------------------------------------------------------------------------------------------------------------
act_re_procdef 流程定义:id hellowrd1:4 helloword为流程名 1为版本【第几次部署版本就为几】  deployId为部署表中的主键


单线流程下：proInstance与excution是一样的  --- 如果是多线流程并且有汇合点proInstance数量为1 excution数量为多  --不汇合的情况下数量都为一

流程一启动：
    act_ru_execution，【执行实例】增加一条流程实例
    act_ru_identitylink  增加一条等待办理的人信息
    act_ru_task    流程一启动会到第一个节点，此表也增加一条数据

完成一个节点:
    act_ru_execution，act_id【活动id】会改变  数量不会变


流程结束:
    这几张ru表中都没数据

历史表:
    act_hi_procinst:历史流程实例
    act_hi_taskinst:历史任务实例   duration[持续时间]
    act_hi_actinst:历史活动节点
    act_hi_varinst:历史流程变量
    act_hi_identitylink:历史办理人
    act_hi_comment:历史批注
    act_hi_attachment:附件表

--------------------------管理流程定义[增(部署流程)删改查]-----------
act_ge_bytearray，act_re_deployment，act_re_procdef

------------------------------------------------------------------
流程变量的作用域为一个流程实例    结束后变量会保存在历史流程变量表中
流程变量未键值对形式：支持的数据类型[基本类型,date,binary,serilize(存储序列化对象)]
-----------------------------------------------------------------
多连线   设置条件 格式:${count=="xxx"}
排他网关 相当于if else if else if ... else   设置条件[还有一条默认线路] 格式:${count>=123}
-----------------------------------------------------------------
并行网关【例：有两条子线路（也叫并发分支）】
    流程一启动：excution会有三条记录  一条是父线路【流程实例】 两条是子线路【执行实例】
               ru_task的记录随办理程度而不同
    流程结束: 历史流程实例有1条数据【流程实例】
             历史任务4条数据【付款，发货，收货，收款】
             历史活动表有【除了常规的活动节点外   此例中：汇合的并行节点每个执行实例都会有一份
                            模拟购物的并行网关的案例中 共有8个节点 流程执行完之后 共有9个活动节点，实际中执行几次就会有几次活动记录】
    其他:
        连线上不需要加条件，即使加了也会被忽略

