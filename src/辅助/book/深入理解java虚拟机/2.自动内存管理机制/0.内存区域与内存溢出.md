###运行时数据区域
####程序计数器(线程私有)
```$xslt
    当前线程所执行的字节码的行号指示器[字节码解释器通过改变程序计数器来选取下一条需要执行的字节码指令]
    线程安全考虑:每个线程都需要一个独立的程序计数器[为了切换后程序计数器的正确(能够恢复到争取的执行位置)]
    对于java方法，程序计数器生效；native[程序计数器不管用]；唯一没有OOM的区域
```
####java虚拟机栈(线程私有)执行Java方法[字节码]
```
生命周期与线程相同
StackOverflowError:线程请求深度大于虚拟机所允许的深度
OOM:栈动态扩展但是申请不到足够的内存
```
####本地方法栈(线程私有)执行native方法(没有语言限制)
```
hotspot将Java虚拟机栈与本地方法栈合二为一
也存在 StackOverflowError 与 OOM异常
```
####Java堆(共享)
[线程私有分配缓冲区]("https://www.cnblogs.com/straybirds/p/8529924.html")
```$xslt
虚拟机规范[非绝对-栈上分配与逃逸分析]：所有的对象实例与数组都要在堆上分配
堆中大部分是共享的，也有私有的：线程私有分配缓冲区[Eden(分配小对象)]  #小对象在私有线程[线程安全]，大对象得在堆中分配[加锁保证线程安全(效率低)]
堆可扩展
OOM:实例在堆中没有完成分配，并且堆无法扩展
```
####方法区(共享)
```
类信息，常量，静态变量...
jdk1.7 hotsopt用永久带实现了方法区[存在内存泄漏的风险：永久带有-XX:MaxPermSize的上限] --->后来改为使用 native　memory
垃圾回收：常量池回收，类型卸载[低版本存在此区域未完全回收造成内存泄漏]
```
#####运行时常量池(方法区的一部分)
```
编译期生成的各种字面量和符号引用[类加载后]
运行期也可能将新的常量放入常量池[eg:String的intern()]
OOM:无法申请到内存时(eg:不断的intern())
```
####直接内存(不属于JVM)
```
NIO:通过存储在java堆中的DirectByteBuffer对象作为作为分配到的直接内存的引用
```

