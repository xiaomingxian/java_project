####对象的创建(eg(new关键字):克隆，反序列化)
```
<new>指令
    1.类加载(加载，解析，初始化)
        虚拟机遇到new指令时,先去常量池中找类的符号引用(根据指令的参数)，在判断符号引用指向的类有没有被加载(加载,解析,初始化),没有加载就先执行加载流程
    2.分配内存
        指针碰撞[内存规整,根据指针来区分用过和空闲的内存空间][分配空间：将指针向空闲空间移动一个对象的大小[固定大小]] 
        空闲列表[内存不规整，虚拟机维护了一个列表，记录哪些内存可用，分配的时候找出一块足够大的空间分配给对象实例]
        选择--取决与-->[内存是否规整]--取决于-->[采用的垃圾收集是否有压缩整理功能]
            eg:指针碰撞：Serial,ParNew等带压缩过程的收集器
                空闲列表：CMS
    3.内存分配安全
        1.CAS+失败重试
        2.TLAB(Thread Local Allocation Buffer)本地线程分配缓冲
    4.零值(各种类型的默认值)[对象头除外]
    5.对象头：对象哈希码,gc分代年龄信息,类的元数据信息...
<init>初始化
```
####对象的内存布局
```
1 对象头
    类型指针[确定是哪个类的实例]  #并不是所有的虚拟机实现都保留了类型指针，因为查找元数据(类信息)信息不一定要通过实例对象
    运行时数据[哈希码,gc分代年龄,锁状态标志,线程持有的锁,偏向线程ID,偏向时间戳]
    数组类型特别说明：对象头中有一块区域记录数组长度的信息,因为普通对象可以通过元数据得到对象的大小信息，而数组不能
2 实例数据
3 对齐填充[占位作用，hotspot规范要求对象大小必须是8字节的整数倍]
```
####对象的访问
```
1-句柄池 
    栈中引用-->句柄池[到对象实例的指针[指向实例池]，到对象类型的指针[指向方法区类实例]]
    好处：稳定，对象移动[垃圾收集]只需改变句柄池中的指针
2-直接指针[hotspot]
    栈中引用-->堆中实例数据[到方法区中对象类型的指针,对象实例数据]
    好处:速度快[假如一个实例被频繁访问，那么节省了指针定位数据实例的时间(频繁访问节省的时间累加)]
```
####OOM
[代码](../../../../test/java/jvm/book_test/T1OOMTest.java)
```
1-堆溢出[发生此现象要先判断是内存泄[没有回收干净]还是溢出]
2-栈溢出
3-方法区和运行时常量溢出
4-直接内存溢出
```