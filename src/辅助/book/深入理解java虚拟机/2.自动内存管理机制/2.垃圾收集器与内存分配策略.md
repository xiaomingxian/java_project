```
程序计数器,虚拟机栈,本地方法栈随线程而生随线程而死[不需要考虑回收问题,线程结束时就自动回收了]
引用计数[java不用]
可达性分析[不在gc root引用链上]
    GC Root:
        虚拟机栈(栈中的本地变量表)中引用的对象[指向对象/句柄之类的指针]
        方法区中静态属性/常量引用的对象
        本地方法栈中引用的对象
```
```
引用：强，软，弱，虚
```
```
可达性分析的两次标记：
    1-没有在gc root引用链上会被标记一次
    2-如果这个对象判定为有必要执行finalized()方法-此对象会被放入F-Queue队列-->稍后由虚拟机自动建立的低优先级的 Finalizer线程去执行
对象的自我拯救：
    重写finalized()方法  并在方法中将此对象加入引用链(将对象赋值给某个变量) finalized()最多被系统调用一次(只能拯救一次)
```
```
方法区的回收：
    废弃常量：没有地方引用这个字面常量
    无用的类：
        堆中不存在该类的任何实例
        该类的的ClassLoader已经被回收
        该类对应的java.lang.Class对象没有在任何地方被引用,无法在任何地方通过反射访问该类的方法
      场景:频繁使用自定义ClassLoader的场景都需要虚拟机具备自动卸载类的功能，以保证永久代不会溢出
        eg:ByteCode框架[反射,动态代理,CgLib],动态生成jsp,OSGI等
```